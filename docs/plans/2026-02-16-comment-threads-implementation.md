# Comment Threads Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build an Obsidian plugin that brings Gutter's three-file inline commenting system to Obsidian, fully compatible with Gutter's comment format.

**Architecture:** CM6 ViewPlugin for source/live-preview highlighting, MarkdownPostProcessor for reading view, ItemView sidebar panel for thread management. Plain class state management (no React/Zustand). Obsidian Vault API for persistence.

**Tech Stack:** TypeScript, Obsidian API, CodeMirror 6 (@codemirror/view, @codemirror/state), esbuild

---

### Task 1: Project Scaffold

**Files:**
- Create: `manifest.json`
- Create: `versions.json`
- Create: `package.json`
- Create: `tsconfig.json`
- Create: `esbuild.config.mjs`
- Create: `.gitignore`

**Step 1: Create manifest.json**

```json
{
  "id": "comment-threads",
  "name": "Comment Threads",
  "version": "0.1.0",
  "minAppVersion": "0.15.0",
  "description": "Inline threaded comments for collaborative markdown editing. Compatible with Gutter.",
  "author": "Dave Rigie",
  "isDesktopOnly": false
}
```

**Step 2: Create versions.json**

```json
{
  "0.1.0": "0.15.0"
}
```

**Step 3: Create package.json**

```json
{
  "name": "obsidian-comment-threads",
  "version": "0.1.0",
  "description": "Inline threaded comments for Obsidian",
  "main": "main.js",
  "type": "module",
  "scripts": {
    "dev": "node esbuild.config.mjs",
    "build": "tsc -noEmit -skipLibCheck && node esbuild.config.mjs production"
  },
  "license": "MIT",
  "devDependencies": {
    "@types/node": "^16.11.6",
    "esbuild": "0.25.5",
    "tslib": "2.4.0",
    "typescript": "^5.8.3",
    "obsidian": "latest",
    "@codemirror/state": "^6.0.0",
    "@codemirror/view": "^6.0.0"
  }
}
```

Note: `obsidian`, `@codemirror/state`, `@codemirror/view` are devDependencies for types only â€” they're externalized at build time and provided by Obsidian at runtime.

**Step 4: Create tsconfig.json**

```json
{
  "compilerOptions": {
    "baseUrl": "src",
    "inlineSourceMap": true,
    "inlineSources": true,
    "module": "ESNext",
    "target": "ES6",
    "allowJs": true,
    "noImplicitAny": true,
    "noImplicitThis": true,
    "noImplicitReturns": true,
    "moduleResolution": "node",
    "importHelpers": true,
    "noUncheckedIndexedAccess": true,
    "isolatedModules": true,
    "strictNullChecks": true,
    "strictBindCallApply": true,
    "allowSyntheticDefaultImports": true,
    "useUnknownInCatchVariables": true,
    "lib": ["DOM", "ES5", "ES6", "ES7"]
  },
  "include": ["src/**/*.ts"]
}
```

**Step 5: Create esbuild.config.mjs**

```javascript
import esbuild from "esbuild";
import process from "process";
import { builtinModules } from "node:module";

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = process.argv[2] === "production";

const context = await esbuild.context({
  banner: { js: banner },
  entryPoints: ["src/main.ts"],
  bundle: true,
  external: [
    "obsidian",
    "electron",
    "@codemirror/autocomplete",
    "@codemirror/collab",
    "@codemirror/commands",
    "@codemirror/language",
    "@codemirror/lint",
    "@codemirror/search",
    "@codemirror/state",
    "@codemirror/view",
    "@lezer/common",
    "@lezer/highlight",
    "@lezer/lr",
    ...builtinModules,
  ],
  format: "cjs",
  target: "es2018",
  logLevel: "info",
  sourcemap: prod ? false : "inline",
  treeShaking: true,
  outfile: "main.js",
  minify: prod,
});

if (prod) {
  await context.rebuild();
  process.exit(0);
} else {
  await context.watch();
}
```

**Step 6: Create .gitignore**

```
node_modules/
main.js
*.js.map
data.json
```

**Step 7: Install dependencies**

Run: `cd /Users/daverigie/Documents/obsidian-comment-threads && npm install`

**Step 8: Verify TypeScript compiles**

Run: `cd /Users/daverigie/Documents/obsidian-comment-threads && npx tsc -noEmit -skipLibCheck`
Expected: No errors (no source files yet, should be clean)

**Step 9: Commit**

```bash
git add manifest.json versions.json package.json tsconfig.json esbuild.config.mjs .gitignore
git commit -m "feat: scaffold Obsidian plugin project"
```

---

### Task 2: Type Definitions

**Files:**
- Create: `src/types.ts`

**Step 1: Create type definitions**

Port directly from Gutter's `types/comments.ts`:

```typescript
export interface CommentMessage {
  id: string;
  author: string;
  timestamp: string; // ISO 8601 UTC
  body: string;
}

export interface CommentThread {
  thread: CommentMessage[];
  resolved: boolean;
  resolvedBy?: string;
  resolvedAt?: string; // ISO 8601 UTC
  createdAt: string; // ISO 8601 UTC
}

export interface CommentsFile {
  version: 1;
  comments: Record<string, CommentThread>;
}

export interface CommentThreadsSettings {
  authorName: string;
  autoOpenPanel: boolean;
  generateCompanion: boolean;
}

export const DEFAULT_SETTINGS: CommentThreadsSettings = {
  authorName: "",
  autoOpenPanel: true,
  generateCompanion: true,
};
```

**Step 2: Verify it compiles**

Run: `cd /Users/daverigie/Documents/obsidian-comment-threads && npx tsc -noEmit -skipLibCheck`
Expected: No errors

**Step 3: Commit**

```bash
git add src/types.ts
git commit -m "feat: add comment type definitions"
```

---

### Task 3: Comment Store

**Files:**
- Create: `src/comment-store.ts`

**Step 1: Create the store**

Port Gutter's Zustand store to a plain class with a callback-based change notification system:

```typescript
import type { CommentThread, CommentsFile } from "./types";

function generateId(): string {
  return "m_" + Math.random().toString(36).substring(2, 10);
}

type Listener = () => void;

export class CommentStore {
  threads: Record<string, CommentThread> = {};
  private listeners: Set<Listener> = new Set();

  subscribe(listener: Listener): () => void {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  private notify(): void {
    for (const listener of this.listeners) {
      listener();
    }
  }

  loadComments(data: CommentsFile): void {
    this.threads = data.comments || {};
    this.notify();
  }

  getCommentsFile(): CommentsFile {
    return { version: 1, comments: this.threads };
  }

  getThreadIds(): string[] {
    return Object.keys(this.threads).sort((a, b) => {
      const numA = parseInt(a.replace("c", ""), 10);
      const numB = parseInt(b.replace("c", ""), 10);
      return numA - numB;
    });
  }

  getNextCommentId(): string {
    const ids = Object.keys(this.threads);
    if (ids.length === 0) return "c1";
    const maxNum = Math.max(
      ...ids.map((id) => parseInt(id.replace("c", ""), 10))
    );
    return `c${maxNum + 1}`;
  }

  addThread(commentId: string, author: string, body: string): void {
    const now = new Date().toISOString();
    this.threads = {
      ...this.threads,
      [commentId]: {
        thread: [{ id: generateId(), author, timestamp: now, body }],
        resolved: false,
        createdAt: now,
      },
    };
    this.notify();
  }

  addReply(commentId: string, author: string, body: string): void {
    const thread = this.threads[commentId];
    if (!thread) return;
    const now = new Date().toISOString();
    this.threads = {
      ...this.threads,
      [commentId]: {
        ...thread,
        thread: [
          ...thread.thread,
          { id: generateId(), author, timestamp: now, body },
        ],
      },
    };
    this.notify();
  }

  resolveThread(commentId: string, author: string): void {
    const thread = this.threads[commentId];
    if (!thread) return;
    const now = new Date().toISOString();
    this.threads = {
      ...this.threads,
      [commentId]: {
        ...thread,
        resolved: true,
        resolvedBy: author,
        resolvedAt: now,
      },
    };
    this.notify();
  }

  unresolveThread(commentId: string): void {
    const thread = this.threads[commentId];
    if (!thread) return;
    this.threads = {
      ...this.threads,
      [commentId]: {
        ...thread,
        resolved: false,
        resolvedBy: undefined,
        resolvedAt: undefined,
      },
    };
    this.notify();
  }

  deleteThread(commentId: string): void {
    const { [commentId]: _, ...rest } = this.threads;
    this.threads = rest;
    this.notify();
  }

  clearAll(): void {
    this.threads = {};
    this.notify();
  }

  hasComments(): boolean {
    return Object.keys(this.threads).length > 0;
  }
}
```

**Step 2: Verify it compiles**

Run: `cd /Users/daverigie/Documents/obsidian-comment-threads && npx tsc -noEmit -skipLibCheck`
Expected: No errors

**Step 3: Commit**

```bash
git add src/comment-store.ts
git commit -m "feat: add CommentStore with thread CRUD operations"
```

---

### Task 4: Companion File Builder

**Files:**
- Create: `src/companion-builder.ts`

**Step 1: Create the companion builder**

Port Gutter's `buildCompanionMarkdown()` almost verbatim:

```typescript
import type { CommentsFile } from "./types";

const MARKER_RE = /<mark>([\s\S]*?)<\/mark><sup>\[c(\d+)\]<\/sup>/g;

function formatDate(iso: string): string {
  const d = new Date(iso);
  return (
    d.toLocaleDateString("en-US", {
      month: "short",
      day: "numeric",
      year: "numeric",
    }) +
    " " +
    d.toLocaleTimeString("en-US", {
      hour: "numeric",
      minute: "2-digit",
    })
  );
}

export function buildCompanionMarkdown(
  fileName: string,
  markdownContent: string,
  commentsFile: CommentsFile
): string {
  const lines: string[] = [];

  lines.push(`# Comments â€” ${fileName}`);
  lines.push("");
  lines.push(
    "*Generated by Comment Threads. Do not edit â€” regenerated on save.*"
  );
  lines.push("");
  lines.push("---");

  // Extract anchors in document order
  const anchors: { id: string; text: string }[] = [];
  let match;
  const re = new RegExp(MARKER_RE.source, "g");
  while ((match = re.exec(markdownContent)) !== null) {
    let text = match[1]!;
    if (text.length > 80) text = text.slice(0, 80) + "...";
    anchors.push({ id: `c${match[2]}`, text });
  }

  // Include unanchored threads (marker deleted but thread remains)
  const anchoredIds = new Set(anchors.map((a) => a.id));
  const allIds = Object.keys(commentsFile.comments);
  const unanchored = allIds.filter((id) => !anchoredIds.has(id));

  const orderedEntries = [
    ...anchors.map((a) => ({ id: a.id, text: a.text })),
    ...unanchored.map((id) => ({ id, text: "(unanchored)" })),
  ];

  let resolvedCount = 0;
  let openCount = 0;

  for (const entry of orderedEntries) {
    const thread = commentsFile.comments[entry.id];
    if (!thread) continue;

    lines.push("");
    lines.push(`> **[${entry.id}]** on "${entry.text}"`);
    lines.push("");

    for (const msg of thread.thread) {
      lines.push(`**${msg.author}** â€” ${formatDate(msg.timestamp)}`);
      lines.push(msg.body);
      lines.push("");
    }

    if (thread.resolved) {
      resolvedCount++;
      lines.push(
        `âœ… *Resolved by ${thread.resolvedBy} â€” ${thread.resolvedAt ? formatDate(thread.resolvedAt) : ""}*`
      );
    } else {
      openCount++;
      lines.push("ðŸŸ¡ *Open*");
    }

    lines.push("");
    lines.push("---");
  }

  const total = resolvedCount + openCount;
  lines.push("");
  lines.push(
    `*${total} comment${total !== 1 ? "s" : ""} (${resolvedCount} resolved, ${openCount} open)*`
  );
  lines.push("");

  return lines.join("\n");
}
```

**Step 2: Verify it compiles**

Run: `cd /Users/daverigie/Documents/obsidian-comment-threads && npx tsc -noEmit -skipLibCheck`
Expected: No errors

**Step 3: Commit**

```bash
git add src/companion-builder.ts
git commit -m "feat: add companion markdown builder (port from Gutter)"
```

---

### Task 5: Comment File I/O

**Files:**
- Create: `src/comment-file-io.ts`

**Step 1: Create the file I/O module**

```typescript
import { TFile, Vault } from "obsidian";
import type { CommentsFile } from "./types";
import { CommentStore } from "./comment-store";
import { buildCompanionMarkdown } from "./companion-builder";

function commentsJsonPath(mdPath: string): string {
  return mdPath.replace(/\.md$/, ".comments.json");
}

function companionMdPath(mdPath: string): string {
  return mdPath.replace(/\.md$/, ".comments.md");
}

export class CommentFileIO {
  constructor(
    private vault: Vault,
    private store: CommentStore
  ) {}

  async loadComments(mdPath: string): Promise<void> {
    const jsonPath = commentsJsonPath(mdPath);
    try {
      const file = this.vault.getFileByPath(jsonPath);
      if (file) {
        const content = await this.vault.read(file);
        const data: CommentsFile = JSON.parse(content);
        this.store.loadComments(data);
      } else {
        this.store.loadComments({ version: 1, comments: {} });
      }
    } catch {
      this.store.loadComments({ version: 1, comments: {} });
    }
  }

  async saveComments(mdPath: string): Promise<void> {
    const jsonPath = commentsJsonPath(mdPath);
    const data = this.store.getCommentsFile();
    const hasComments = Object.keys(data.comments).length > 0;

    if (hasComments) {
      const json = JSON.stringify(data, null, 2);
      const existing = this.vault.getFileByPath(jsonPath);
      if (existing) {
        await this.vault.modify(existing, json);
      } else {
        await this.vault.create(jsonPath, json);
      }
    } else {
      // No comments left â€” delete sidecar files
      await this.deleteFile(jsonPath);
      await this.deleteFile(companionMdPath(mdPath));
    }
  }

  async saveCompanion(
    mdPath: string,
    markdownContent: string
  ): Promise<void> {
    const companionPath = companionMdPath(mdPath);
    const data = this.store.getCommentsFile();
    const hasComments = Object.keys(data.comments).length > 0;

    if (!hasComments) {
      await this.deleteFile(companionPath);
      return;
    }

    const fileName = mdPath.split("/").pop() || "document.md";
    const companion = buildCompanionMarkdown(fileName, markdownContent, data);

    const existing = this.vault.getFileByPath(companionPath);
    if (existing) {
      await this.vault.modify(existing, companion);
    } else {
      await this.vault.create(companionPath, companion);
    }
  }

  private async deleteFile(path: string): Promise<void> {
    const file = this.vault.getFileByPath(path);
    if (file) {
      await this.vault.delete(file);
    }
  }

  isCommentsSidecar(path: string): boolean {
    return path.endsWith(".comments.json") || path.endsWith(".comments.md");
  }
}
```

**Step 2: Verify it compiles**

Run: `cd /Users/daverigie/Documents/obsidian-comment-threads && npx tsc -noEmit -skipLibCheck`
Expected: No errors

**Step 3: Commit**

```bash
git add src/comment-file-io.ts
git commit -m "feat: add comment file I/O with Vault API"
```

---

### Task 6: Settings Tab

**Files:**
- Create: `src/settings.ts`

**Step 1: Create the settings tab**

```typescript
import { App, PluginSettingTab, Setting } from "obsidian";
import type CommentThreadsPlugin from "./main";

export class CommentThreadsSettingTab extends PluginSettingTab {
  plugin: CommentThreadsPlugin;

  constructor(app: App, plugin: CommentThreadsPlugin) {
    super(app, plugin);
    this.plugin = plugin;
  }

  display(): void {
    const { containerEl } = this;
    containerEl.empty();

    new Setting(containerEl)
      .setName("Author name")
      .setDesc("Your display name shown on comment threads.")
      .addText((text) =>
        text
          .setPlaceholder("Enter your name")
          .setValue(this.plugin.settings.authorName)
          .onChange(async (value) => {
            this.plugin.settings.authorName = value;
            await this.plugin.saveSettings();
          })
      );

    new Setting(containerEl)
      .setName("Auto-open panel")
      .setDesc(
        "Automatically show the comments panel when opening a file with comments."
      )
      .addToggle((toggle) =>
        toggle
          .setValue(this.plugin.settings.autoOpenPanel)
          .onChange(async (value) => {
            this.plugin.settings.autoOpenPanel = value;
            await this.plugin.saveSettings();
          })
      );

    new Setting(containerEl)
      .setName("Generate companion file")
      .setDesc(
        "Auto-generate a human-readable .comments.md file alongside .comments.json."
      )
      .addToggle((toggle) =>
        toggle
          .setValue(this.plugin.settings.generateCompanion)
          .onChange(async (value) => {
            this.plugin.settings.generateCompanion = value;
            await this.plugin.saveSettings();
          })
      );
  }
}
```

**Step 2: Verify it compiles**

This will have a type error because `main.ts` doesn't exist yet. That's fine â€” it will resolve in Task 10.

**Step 3: Commit**

```bash
git add src/settings.ts
git commit -m "feat: add plugin settings tab"
```

---

### Task 7: CM6 Comment Decoration (ViewPlugin)

**Files:**
- Create: `src/cm6/comment-decoration.ts`

**Step 1: Create the CM6 ViewPlugin**

This plugin scans the document text for `<mark>...</mark><sup>[cN]</sup>` patterns and applies decorations to highlight the text and hide the HTML tags.

```typescript
import { RangeSetBuilder } from "@codemirror/state";
import {
  Decoration,
  DecorationSet,
  EditorView,
  PluginSpec,
  PluginValue,
  ViewPlugin,
  ViewUpdate,
  WidgetType,
} from "@codemirror/view";

const COMMENT_RE =
  /<mark>([\s\S]*?)<\/mark><sup>\[c(\d+)\]<\/sup>/g;

/**
 * Small widget that renders a clickable comment badge like [c1]
 * after the highlighted text.
 */
class CommentBadgeWidget extends WidgetType {
  constructor(readonly commentId: string) {
    super();
  }

  toDOM(): HTMLElement {
    const badge = document.createElement("span");
    badge.className = "ct-comment-badge";
    badge.textContent = `[${this.commentId}]`;
    badge.dataset.commentId = this.commentId;
    return badge;
  }

  eq(other: CommentBadgeWidget): boolean {
    return this.commentId === other.commentId;
  }
}

export interface CommentRange {
  fullFrom: number;
  fullTo: number;
  textFrom: number;
  textTo: number;
  commentId: string;
}

/**
 * Scans the full document for comment markers and returns their positions.
 */
function findCommentRanges(docText: string): CommentRange[] {
  const ranges: CommentRange[] = [];
  const re = new RegExp(COMMENT_RE.source, "g");
  let match;
  while ((match = re.exec(docText)) !== null) {
    const fullFrom = match.index;
    const fullTo = match.index + match[0].length;
    // <mark> is 6 chars, </mark><sup>[cN]</sup> is the rest
    const textFrom = fullFrom + 6; // after <mark>
    const textTo = textFrom + match[1].length; // before </mark>
    const commentId = `c${match[2]}`;
    ranges.push({ fullFrom, fullTo, textFrom, textTo, commentId });
  }
  return ranges;
}

// Decoration that hides the raw HTML tags
const hiddenDeco = Decoration.replace({});

class CommentDecorationPlugin implements PluginValue {
  decorations: DecorationSet;
  ranges: CommentRange[] = [];

  constructor(view: EditorView) {
    const result = this.buildDecorations(view);
    this.decorations = result.decorations;
    this.ranges = result.ranges;
  }

  update(update: ViewUpdate): void {
    if (update.docChanged || update.viewportChanged) {
      const result = this.buildDecorations(update.view);
      this.decorations = result.decorations;
      this.ranges = result.ranges;
    }
  }

  destroy(): void {}

  private buildDecorations(
    view: EditorView
  ): { decorations: DecorationSet; ranges: CommentRange[] } {
    const builder = new RangeSetBuilder<Decoration>();
    const docText = view.state.doc.toString();
    const ranges = findCommentRanges(docText);

    for (const r of ranges) {
      // Hide <mark> opening tag
      builder.add(r.fullFrom, r.textFrom, hiddenDeco);
      // Highlight the actual text
      builder.add(
        r.textFrom,
        r.textTo,
        Decoration.mark({
          class: "ct-comment-highlight",
          attributes: { "data-comment-id": r.commentId },
        })
      );
      // Hide </mark><sup>[cN]</sup> and replace with badge widget
      builder.add(
        r.textTo,
        r.fullTo,
        Decoration.replace({
          widget: new CommentBadgeWidget(r.commentId),
        })
      );
    }

    return { decorations: builder.finish(), ranges };
  }
}

const pluginSpec: PluginSpec<CommentDecorationPlugin> = {
  decorations: (v) => v.decorations,
};

export const commentDecorationPlugin = ViewPlugin.fromClass(
  CommentDecorationPlugin,
  pluginSpec
);

export { findCommentRanges as findCommentRangesInText };
```

**Step 2: Verify it compiles**

Run: `cd /Users/daverigie/Documents/obsidian-comment-threads && npx tsc -noEmit -skipLibCheck`
Expected: No errors

**Step 3: Commit**

```bash
git add src/cm6/comment-decoration.ts
git commit -m "feat: add CM6 ViewPlugin for comment decoration in live preview"
```

---

### Task 8: Markdown Post-Processor (Reading View)

**Files:**
- Create: `src/post-processor.ts`

**Step 1: Create the post-processor**

```typescript
import { MarkdownPostProcessorContext } from "obsidian";

/**
 * Post-processor for reading view. Obsidian natively renders <mark> as
 * highlighted text. This processor finds <mark> elements followed by
 * <sup>[cN]</sup> elements, adds interactive styling, and hides the
 * superscript reference.
 */
export function commentPostProcessor(
  el: HTMLElement,
  ctx: MarkdownPostProcessorContext,
  onClickComment: (commentId: string) => void
): void {
  // Find all <sup> elements that contain comment references like [c1]
  const sups = el.querySelectorAll("sup");
  for (const sup of Array.from(sups)) {
    const text = sup.textContent || "";
    const match = text.match(/^\[c(\d+)\]$/);
    if (!match) continue;

    const commentId = `c${match[1]}`;
    const mark = sup.previousElementSibling;

    // The <mark> should be the previous sibling
    if (mark && mark.tagName === "MARK") {
      mark.classList.add("ct-comment-highlight");
      mark.setAttribute("data-comment-id", commentId);
      mark.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        onClickComment(commentId);
      });
    }

    // Replace <sup>[c1]</sup> with a small badge
    const badge = document.createElement("span");
    badge.className = "ct-comment-badge";
    badge.textContent = `[${commentId}]`;
    badge.dataset.commentId = commentId;
    badge.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      onClickComment(commentId);
    });
    sup.replaceWith(badge);
  }
}
```

**Step 2: Verify it compiles**

Run: `cd /Users/daverigie/Documents/obsidian-comment-threads && npx tsc -noEmit -skipLibCheck`
Expected: No errors

**Step 3: Commit**

```bash
git add src/post-processor.ts
git commit -m "feat: add markdown post-processor for reading view"
```

---

### Task 9: Comments Panel (Sidebar ItemView)

**Files:**
- Create: `src/views/comments-panel.ts`

**Step 1: Create the ItemView**

This is the largest single file. It renders the full comment thread panel using Obsidian's DOM API (no React).

```typescript
import { ItemView, WorkspaceLeaf } from "obsidian";
import type { CommentStore } from "../comment-store";
import type { CommentThread } from "../types";

export const VIEW_TYPE_COMMENT_THREADS = "comment-threads-view";

type FilterMode = "all" | "open" | "resolved";

export class CommentThreadsView extends ItemView {
  store: CommentStore;
  activeCommentId: string | null = null;
  commentTexts: Record<string, string> = {};
  private filter: FilterMode = "open";
  private unsubscribe: (() => void) | null = null;
  private getAuthor: () => string = () => "Anonymous";
  private onNavigateToComment: (commentId: string) => void = () => {};

  constructor(leaf: WorkspaceLeaf, store: CommentStore) {
    super(leaf);
    this.store = store;
  }

  getViewType(): string {
    return VIEW_TYPE_COMMENT_THREADS;
  }

  getDisplayText(): string {
    return "Comment Threads";
  }

  getIcon(): string {
    return "message-square";
  }

  setGetAuthor(fn: () => string): void {
    this.getAuthor = fn;
  }

  setOnNavigateToComment(fn: (commentId: string) => void): void {
    this.onNavigateToComment = fn;
  }

  async onOpen(): Promise<void> {
    this.unsubscribe = this.store.subscribe(() => this.render());
    this.render();
  }

  async onClose(): Promise<void> {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
    }
  }

  setActiveComment(commentId: string | null): void {
    this.activeCommentId = commentId;
    this.render();
  }

  setCommentTexts(texts: Record<string, string>): void {
    this.commentTexts = texts;
    this.render();
  }

  private render(): void {
    const container = this.contentEl;
    container.empty();
    container.addClass("ct-panel");

    const threadIds = this.store.getThreadIds();
    const threads = this.store.threads;
    const totalCount = threadIds.length;
    const resolvedCount = threadIds.filter(
      (id) => threads[id]?.resolved
    ).length;
    const openCount = totalCount - resolvedCount;

    // Header
    const header = container.createDiv({ cls: "ct-panel-header" });

    const titleRow = header.createDiv({ cls: "ct-panel-title-row" });
    titleRow.createSpan({ cls: "ct-panel-title", text: "Comments" });
    if (totalCount > 0) {
      titleRow.createSpan({
        cls: "ct-panel-badge",
        text: String(openCount),
      });
    }

    const controls = header.createDiv({ cls: "ct-panel-controls" });

    // Filter dropdown
    const select = controls.createEl("select", { cls: "ct-panel-filter" });
    const options: [FilterMode, string][] = [
      ["all", `All (${totalCount})`],
      ["open", `Open (${openCount})`],
      ["resolved", `Resolved (${resolvedCount})`],
    ];
    for (const [value, label] of options) {
      const opt = select.createEl("option", { text: label, value });
      if (value === this.filter) opt.selected = true;
    }
    select.addEventListener("change", () => {
      this.filter = select.value as FilterMode;
      this.render();
    });

    // Filter visible threads
    const visibleThreads = threadIds.filter((id) => {
      if (this.filter === "all") return true;
      if (this.filter === "open") return !threads[id]?.resolved;
      return threads[id]?.resolved;
    });

    // Thread list
    const list = container.createDiv({ cls: "ct-thread-list" });

    if (visibleThreads.length === 0) {
      const empty = list.createDiv({ cls: "ct-empty-state" });
      if (totalCount === 0) {
        empty.createEl("p", {
          cls: "ct-empty-title",
          text: "No comments yet",
        });
        empty.createEl("p", {
          cls: "ct-empty-hint",
          text: "Select text and press Cmd+Shift+M to add a comment.",
        });
      } else {
        empty.createEl("p", {
          cls: "ct-empty-title",
          text:
            this.filter === "open" ? "All resolved" : "No resolved comments",
        });
        empty.createEl("p", {
          cls: "ct-empty-hint",
          text: "Try changing the filter.",
        });
      }
      return;
    }

    for (const id of visibleThreads) {
      const thread = threads[id];
      if (!thread) continue;
      this.renderThread(list, id, thread);
    }
  }

  private renderThread(
    parent: HTMLElement,
    commentId: string,
    thread: CommentThread
  ): void {
    const isActive = this.activeCommentId === commentId;
    const el = parent.createDiv({
      cls: `ct-thread ${isActive ? "ct-thread-active" : ""} ${thread.resolved ? "ct-thread-resolved" : ""}`,
    });

    el.addEventListener("click", () => {
      this.activeCommentId = commentId;
      this.onNavigateToComment(commentId);
      this.render();
    });

    // Header row
    const headerRow = el.createDiv({ cls: "ct-thread-header" });
    headerRow.createSpan({
      cls: "ct-thread-id",
      text: `[${commentId}]`,
    });

    const actions = headerRow.createDiv({ cls: "ct-thread-actions" });

    // Resolve/unresolve button
    if (!thread.resolved) {
      const resolveBtn = actions.createEl("button", {
        cls: "ct-btn ct-btn-resolve",
        title: "Resolve",
        text: "âœ“",
      });
      resolveBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.store.resolveThread(commentId, this.getAuthor());
      });
    } else {
      const unresolveBtn = actions.createEl("button", {
        cls: "ct-btn ct-btn-unresolve",
        title: "Unresolve",
        text: "â†©",
      });
      unresolveBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.store.unresolveThread(commentId);
      });
    }

    // Delete button
    const deleteBtn = actions.createEl("button", {
      cls: "ct-btn ct-btn-delete",
      title: "Delete",
      text: "âœ•",
    });
    let deleteConfirmTimeout: number | null = null;
    deleteBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      if (deleteBtn.hasClass("ct-btn-confirm")) {
        this.store.deleteThread(commentId);
        if (deleteConfirmTimeout !== null) {
          window.clearTimeout(deleteConfirmTimeout);
        }
      } else {
        deleteBtn.addClass("ct-btn-confirm");
        deleteBtn.textContent = "Confirm?";
        deleteConfirmTimeout = window.setTimeout(() => {
          deleteBtn.removeClass("ct-btn-confirm");
          deleteBtn.textContent = "âœ•";
        }, 3000);
      }
    });

    // Quoted text
    const quotedText = this.commentTexts[commentId];
    if (quotedText) {
      const quote = el.createDiv({ cls: "ct-thread-quote" });
      const displayText =
        quotedText.length > 80
          ? quotedText.slice(0, 80) + "..."
          : quotedText;
      quote.textContent = `"${displayText}"`;
    }

    // Resolution status
    if (thread.resolved) {
      const status = el.createDiv({ cls: "ct-thread-status-resolved" });
      status.textContent = `Resolved by ${thread.resolvedBy}`;
      if (thread.resolvedAt) {
        status.textContent += ` â€” ${this.formatDate(thread.resolvedAt)}`;
      }
    }

    // Messages
    const messages = el.createDiv({ cls: "ct-thread-messages" });
    for (const msg of thread.thread) {
      const msgEl = messages.createDiv({ cls: "ct-message" });
      const meta = msgEl.createDiv({ cls: "ct-message-meta" });
      meta.createSpan({ cls: "ct-message-author", text: msg.author });
      meta.createSpan({ cls: "ct-message-sep", text: " Â· " });
      meta.createSpan({
        cls: "ct-message-time",
        text: this.formatDate(msg.timestamp),
      });
      msgEl.createEl("p", { cls: "ct-message-body", text: msg.body });
    }

    // Reply input (only for open threads)
    if (!thread.resolved) {
      const replyContainer = el.createDiv({ cls: "ct-reply" });
      const replyInput = replyContainer.createEl("input", {
        cls: "ct-reply-input",
        type: "text",
        placeholder: "Reply...",
      });
      replyInput.addEventListener("click", (e) => e.stopPropagation());
      replyInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          const text = replyInput.value.trim();
          if (!text) return;
          this.store.addReply(commentId, this.getAuthor(), text);
          replyInput.value = "";
        }
      });
    }
  }

  private formatDate(iso: string): string {
    const d = new Date(iso);
    return (
      d.toLocaleDateString("en-US", {
        month: "short",
        day: "numeric",
        year: "numeric",
      }) +
      " " +
      d.toLocaleTimeString("en-US", {
        hour: "numeric",
        minute: "2-digit",
      })
    );
  }
}
```

**Step 2: Verify it compiles**

Run: `cd /Users/daverigie/Documents/obsidian-comment-threads && npx tsc -noEmit -skipLibCheck`
Expected: No errors

**Step 3: Commit**

```bash
git add src/views/comments-panel.ts
git commit -m "feat: add comments panel sidebar view"
```

---

### Task 10: Plugin Entry Point (main.ts)

**Files:**
- Create: `src/main.ts`

**Step 1: Create the main plugin file**

This wires everything together: commands, ribbon, context menu, events, CM6 extension, post-processor, settings, and sidebar panel.

```typescript
import {
  Editor,
  MarkdownFileInfo,
  MarkdownView,
  Menu,
  Modal,
  Notice,
  Plugin,
  TFile,
  WorkspaceLeaf,
} from "obsidian";
import { CommentStore } from "./comment-store";
import { CommentFileIO } from "./comment-file-io";
import {
  CommentThreadsView,
  VIEW_TYPE_COMMENT_THREADS,
} from "./views/comments-panel";
import { CommentThreadsSettingTab } from "./settings";
import { commentDecorationPlugin } from "./cm6/comment-decoration";
import { commentPostProcessor } from "./post-processor";
import type { CommentThreadsSettings } from "./types";
import { DEFAULT_SETTINGS } from "./types";

const MARKER_RE = /<mark>([\s\S]*?)<\/mark><sup>\[c(\d+)\]<\/sup>/g;

export default class CommentThreadsPlugin extends Plugin {
  settings: CommentThreadsSettings = DEFAULT_SETTINGS;
  store: CommentStore = new CommentStore();
  fileIO!: CommentFileIO;
  private currentFilePath: string | null = null;
  private saving = false;

  async onload(): Promise<void> {
    await this.loadSettings();
    this.fileIO = new CommentFileIO(this.app.vault, this.store);

    // Register sidebar view
    this.registerView(VIEW_TYPE_COMMENT_THREADS, (leaf) => {
      const view = new CommentThreadsView(leaf, this.store);
      view.setGetAuthor(() => this.getAuthor());
      view.setOnNavigateToComment((id) => this.scrollToComment(id));
      return view;
    });

    // Register CM6 extension for live preview
    this.registerEditorExtension(commentDecorationPlugin);

    // Register post-processor for reading view
    this.registerMarkdownPostProcessor((el, ctx) => {
      commentPostProcessor(el, ctx, (commentId) => {
        this.setActiveComment(commentId);
        this.activatePanel();
      });
    });

    // Commands
    this.addCommand({
      id: "create-comment",
      name: "Add comment to selection",
      editorCallback: (editor: Editor) => {
        this.createComment(editor);
      },
      hotkeys: [{ modifiers: ["Mod", "Shift"], key: "m" }],
    });

    this.addCommand({
      id: "toggle-panel",
      name: "Toggle comments panel",
      callback: () => this.togglePanel(),
    });

    this.addCommand({
      id: "next-comment",
      name: "Go to next comment",
      editorCallback: (editor: Editor) => {
        this.navigateComment(editor, "next");
      },
    });

    this.addCommand({
      id: "prev-comment",
      name: "Go to previous comment",
      editorCallback: (editor: Editor) => {
        this.navigateComment(editor, "prev");
      },
    });

    // Ribbon icon
    this.addRibbonIcon("message-square", "Comment Threads", () => {
      const view = this.app.workspace.getActiveViewOfType(MarkdownView);
      if (view) {
        const selection = view.editor.getSelection();
        if (selection) {
          this.createComment(view.editor);
          return;
        }
      }
      this.togglePanel();
    });

    // Context menu
    this.registerEvent(
      this.app.workspace.on(
        "editor-menu",
        (menu: Menu, editor: Editor, info: MarkdownView | MarkdownFileInfo) => {
          const selection = editor.getSelection();
          if (selection) {
            menu.addItem((item) => {
              item
                .setTitle("Add comment")
                .setIcon("message-square")
                .onClick(() => this.createComment(editor));
            });
          }
        }
      )
    );

    // Load comments when a file opens
    this.registerEvent(
      this.app.workspace.on("file-open", (file: TFile | null) => {
        if (file && file.extension === "md" && !this.fileIO.isCommentsSidecar(file.path)) {
          this.onFileOpen(file);
        }
      })
    );

    // Save comments when file is modified (debounced via the vault modify event)
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (
          file instanceof TFile &&
          file.path === this.currentFilePath &&
          !this.saving
        ) {
          this.debouncedSave();
        }
      })
    );

    // Settings tab
    this.addSettingTab(new CommentThreadsSettingTab(this.app, this));

    // Subscribe to store changes to save comments
    this.store.subscribe(() => {
      if (this.currentFilePath) {
        this.debouncedSave();
      }
    });
  }

  async onunload(): Promise<void> {
    // Save any pending changes
    if (this.currentFilePath) {
      await this.saveCurrentComments();
    }
  }

  // --- Settings ---

  async loadSettings(): Promise<void> {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }

  async saveSettings(): Promise<void> {
    await this.saveData(this.settings);
  }

  getAuthor(): string {
    return this.settings.authorName || "Anonymous";
  }

  // --- File handling ---

  private async onFileOpen(file: TFile): Promise<void> {
    this.currentFilePath = file.path;
    await this.fileIO.loadComments(file.path);

    // Extract quoted texts from the file content
    const content = await this.app.vault.read(file);
    this.updateCommentTexts(content);

    // Update panel
    this.updatePanel();

    // Auto-open panel if enabled and there are comments
    if (this.settings.autoOpenPanel && this.store.hasComments()) {
      this.activatePanel();
    }
  }

  private saveTimeout: number | null = null;

  private debouncedSave(): void {
    if (this.saveTimeout !== null) {
      window.clearTimeout(this.saveTimeout);
    }
    this.saveTimeout = window.setTimeout(() => {
      this.saveCurrentComments();
    }, 1000);
  }

  private async saveCurrentComments(): Promise<void> {
    if (!this.currentFilePath || this.saving) return;
    this.saving = true;
    try {
      await this.fileIO.saveComments(this.currentFilePath);

      if (this.settings.generateCompanion) {
        const file = this.app.vault.getFileByPath(this.currentFilePath);
        if (file) {
          const content = await this.app.vault.read(file);
          await this.fileIO.saveCompanion(this.currentFilePath, content);
        }
      }
    } finally {
      this.saving = false;
    }
  }

  // --- Comment creation ---

  private createComment(editor: Editor): void {
    const selection = editor.getSelection();
    if (!selection) {
      new Notice("Select text first to add a comment.");
      return;
    }

    if (!this.settings.authorName) {
      new Notice(
        "Please set your author name in Comment Threads settings first."
      );
      return;
    }

    const commentId = this.store.getNextCommentId();

    // Show modal to enter comment body
    new CommentInputModal(this.app, (body) => {
      // Add the thread to the store
      this.store.addThread(commentId, this.getAuthor(), body);

      // Wrap selection with markers in the editor
      const wrapped = `<mark>${selection}</mark><sup>[${commentId}]</sup>`;
      editor.replaceSelection(wrapped);

      // Open panel and set active
      this.setActiveComment(commentId);
      this.activatePanel();

      new Notice(`Comment ${commentId} added.`);
    }).open();
  }

  // --- Comment navigation ---

  private updateCommentTexts(content: string): void {
    const texts: Record<string, string> = {};
    const re = new RegExp(MARKER_RE.source, "g");
    let match;
    while ((match = re.exec(content)) !== null) {
      const commentId = `c${match[2]}`;
      texts[commentId] = match[1];
    }

    // Update the panel
    const leaves = this.app.workspace.getLeavesOfType(
      VIEW_TYPE_COMMENT_THREADS
    );
    for (const leaf of leaves) {
      if (leaf.view instanceof CommentThreadsView) {
        leaf.view.setCommentTexts(texts);
      }
    }
  }

  private scrollToComment(commentId: string): void {
    const view = this.app.workspace.getActiveViewOfType(MarkdownView);
    if (!view) return;
    const editor = view.editor;
    const content = editor.getValue();

    const re = new RegExp(MARKER_RE.source, "g");
    let match;
    while ((match = re.exec(content)) !== null) {
      if (`c${match[2]}` === commentId) {
        const pos = editor.offsetToPos(match.index);
        editor.setCursor(pos);
        editor.scrollIntoView(
          { from: pos, to: editor.offsetToPos(match.index + match[0].length) },
          true
        );
        break;
      }
    }
  }

  private navigateComment(editor: Editor, direction: "next" | "prev"): void {
    const content = editor.getValue();
    const cursor = editor.posToOffset(editor.getCursor());

    const re = new RegExp(MARKER_RE.source, "g");
    const positions: number[] = [];
    let match;
    while ((match = re.exec(content)) !== null) {
      positions.push(match.index);
    }

    if (positions.length === 0) return;

    let target: number;
    if (direction === "next") {
      target = positions.find((p) => p > cursor) ?? positions[0]!;
    } else {
      target =
        [...positions].reverse().find((p) => p < cursor) ??
        positions[positions.length - 1]!;
    }

    const pos = editor.offsetToPos(target);
    editor.setCursor(pos);
    editor.scrollIntoView({ from: pos, to: pos }, true);
  }

  // --- Panel management ---

  private setActiveComment(commentId: string): void {
    const leaves = this.app.workspace.getLeavesOfType(
      VIEW_TYPE_COMMENT_THREADS
    );
    for (const leaf of leaves) {
      if (leaf.view instanceof CommentThreadsView) {
        leaf.view.setActiveComment(commentId);
      }
    }
  }

  private updatePanel(): void {
    const leaves = this.app.workspace.getLeavesOfType(
      VIEW_TYPE_COMMENT_THREADS
    );
    for (const leaf of leaves) {
      if (leaf.view instanceof CommentThreadsView) {
        // Re-render triggers from store subscription
        leaf.view.setActiveComment(null);
      }
    }
  }

  async activatePanel(): Promise<void> {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_COMMENT_THREADS);

    if (leaves.length > 0) {
      workspace.revealLeaf(leaves[0]);
      return;
    }

    const leaf = workspace.getRightLeaf(false);
    if (leaf) {
      await leaf.setViewState({
        type: VIEW_TYPE_COMMENT_THREADS,
        active: true,
      });
      workspace.revealLeaf(leaf);
    }
  }

  private async togglePanel(): Promise<void> {
    const leaves = this.app.workspace.getLeavesOfType(
      VIEW_TYPE_COMMENT_THREADS
    );
    if (leaves.length > 0) {
      leaves[0].detach();
    } else {
      await this.activatePanel();
    }
  }
}

/**
 * Simple modal for entering a comment body.
 */
class CommentInputModal extends Modal {
  private onSubmit: (body: string) => void;

  constructor(app: import("obsidian").App, onSubmit: (body: string) => void) {
    super(app);
    this.onSubmit = onSubmit;
  }

  onOpen(): void {
    const { contentEl } = this;
    contentEl.createEl("h3", { text: "Add Comment" });

    const input = contentEl.createEl("textarea", {
      cls: "ct-comment-input-modal-textarea",
      placeholder: "Enter your comment...",
    });
    input.rows = 3;
    input.focus();

    const btnContainer = contentEl.createDiv({
      cls: "ct-comment-input-modal-buttons",
    });

    const submitBtn = btnContainer.createEl("button", {
      text: "Add Comment",
      cls: "mod-cta",
    });
    submitBtn.addEventListener("click", () => {
      const body = input.value.trim();
      if (body) {
        this.onSubmit(body);
        this.close();
      }
    });

    const cancelBtn = btnContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => this.close());

    // Submit on Cmd/Ctrl+Enter
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        const body = input.value.trim();
        if (body) {
          this.onSubmit(body);
          this.close();
        }
      }
    });
  }

  onClose(): void {
    this.contentEl.empty();
  }
}
```

**Step 2: Verify it compiles**

Run: `cd /Users/daverigie/Documents/obsidian-comment-threads && npx tsc -noEmit -skipLibCheck`
Expected: No errors

**Step 3: Commit**

```bash
git add src/main.ts
git commit -m "feat: add main plugin entry point wiring everything together"
```

---

### Task 11: Styles

**Files:**
- Create: `styles.css`

**Step 1: Create the stylesheet**

Obsidian loads `styles.css` from the plugin root automatically.

```css
/* ============================================
   Comment Threads - Obsidian Plugin Styles
   ============================================ */

/* --- Inline comment highlights (editor + reading view) --- */

.ct-comment-highlight {
  background-color: rgba(255, 208, 0, 0.25);
  border-bottom: 2px solid rgba(255, 208, 0, 0.6);
  border-radius: 2px;
  cursor: pointer;
  transition: background-color 0.15s ease;
}

.ct-comment-highlight:hover {
  background-color: rgba(255, 208, 0, 0.4);
}

.ct-comment-highlight.ct-active {
  background-color: rgba(255, 208, 0, 0.5);
  border-bottom-color: rgba(255, 208, 0, 0.9);
}

/* Comment badge [c1] */
.ct-comment-badge {
  font-size: 0.7em;
  vertical-align: super;
  color: var(--text-muted);
  opacity: 0.6;
  cursor: pointer;
  margin-left: 1px;
  transition: opacity 0.15s ease;
}

.ct-comment-badge:hover {
  opacity: 1;
}

/* --- Panel styles --- */

.ct-panel {
  display: flex;
  flex-direction: column;
  height: 100%;
  background: var(--background-secondary);
}

.ct-panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 12px;
  border-bottom: 1px solid var(--background-modifier-border);
}

.ct-panel-title-row {
  display: flex;
  align-items: center;
  gap: 8px;
}

.ct-panel-title {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--text-muted);
}

.ct-panel-badge {
  font-size: 11px;
  background: var(--interactive-accent);
  color: var(--text-on-accent);
  padding: 1px 6px;
  border-radius: 10px;
  font-weight: 500;
  min-width: 18px;
  text-align: center;
}

.ct-panel-controls {
  display: flex;
  align-items: center;
  gap: 4px;
}

.ct-panel-filter {
  font-size: 11px;
  background: var(--background-primary);
  color: var(--text-normal);
  border: 1px solid var(--background-modifier-border);
  border-radius: 4px;
  padding: 2px 6px;
  outline: none;
}

.ct-panel-filter:focus {
  border-color: var(--interactive-accent);
}

/* --- Thread list --- */

.ct-thread-list {
  flex: 1;
  overflow-y: auto;
  padding: 8px 0;
}

.ct-empty-state {
  text-align: center;
  padding: 48px 16px;
  color: var(--text-muted);
}

.ct-empty-title {
  font-size: 13px;
  font-weight: 500;
  color: var(--text-faint);
  margin-bottom: 4px;
}

.ct-empty-hint {
  font-size: 12px;
}

/* --- Individual thread --- */

.ct-thread {
  margin: 0 8px 8px;
  padding: 0;
  border-radius: 8px;
  border: 1px solid var(--background-modifier-border);
  border-left: 3px solid transparent;
  background: var(--background-primary);
  cursor: pointer;
  transition: all 0.15s ease;
}

.ct-thread:hover {
  border-left-color: var(--background-modifier-border);
}

.ct-thread-active {
  border-left-color: var(--interactive-accent) !important;
  background: var(--background-primary-alt);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
}

.ct-thread-resolved {
  opacity: 0.5;
}

.ct-thread-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 12px;
}

.ct-thread-id {
  font-size: 11px;
  font-family: var(--font-monospace);
  color: var(--text-muted);
}

.ct-thread-actions {
  display: flex;
  align-items: center;
  gap: 2px;
}

/* --- Buttons --- */

.ct-btn {
  background: none;
  border: none;
  padding: 4px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  line-height: 1;
  color: var(--text-muted);
  transition: all 0.15s ease;
}

.ct-btn:hover {
  background: var(--background-modifier-hover);
}

.ct-btn-resolve {
  color: var(--text-success);
}

.ct-btn-resolve:hover {
  color: var(--text-success);
}

.ct-btn-unresolve {
  color: var(--text-muted);
}

.ct-btn-delete:hover {
  color: var(--text-error);
}

.ct-btn-confirm {
  color: var(--text-error) !important;
  background: var(--background-modifier-hover);
  font-size: 11px;
  font-weight: 600;
  padding: 2px 6px;
}

/* --- Quoted text --- */

.ct-thread-quote {
  margin: 0 12px 6px;
  font-size: 12px;
  color: var(--text-faint);
  font-style: italic;
  border-left: 3px solid var(--interactive-accent);
  padding-left: 8px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* --- Thread status --- */

.ct-thread-status-resolved {
  padding: 0 12px 4px;
  font-size: 11px;
  color: var(--text-success);
}

/* --- Messages --- */

.ct-thread-messages {
  padding: 0 12px 8px;
}

.ct-message {
  margin-bottom: 8px;
}

.ct-message:last-child {
  margin-bottom: 0;
}

.ct-message-meta {
  display: flex;
  align-items: baseline;
  gap: 0;
}

.ct-message-author {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-normal);
}

.ct-message-sep {
  font-size: 10px;
  color: var(--text-muted);
  margin: 0 4px;
}

.ct-message-time {
  font-size: 11px;
  color: var(--text-muted);
}

.ct-message-body {
  font-size: 13px;
  color: var(--text-normal);
  margin-top: 2px;
  line-height: 1.5;
}

/* --- Reply input --- */

.ct-reply {
  padding: 0 12px 8px;
}

.ct-reply-input {
  width: 100%;
  font-size: 13px;
  padding: 6px 10px;
  border-radius: 6px;
  border: 1px solid var(--background-modifier-border);
  background: var(--background-primary);
  color: var(--text-normal);
  outline: none;
  transition: border-color 0.15s ease;
}

.ct-reply-input:focus {
  border-color: var(--interactive-accent);
}

.ct-reply-input::placeholder {
  color: var(--text-muted);
}

/* --- Comment input modal --- */

.ct-comment-input-modal-textarea {
  width: 100%;
  min-height: 80px;
  margin: 12px 0;
  padding: 8px 12px;
  border-radius: 6px;
  border: 1px solid var(--background-modifier-border);
  background: var(--background-primary);
  color: var(--text-normal);
  font-size: 14px;
  font-family: inherit;
  resize: vertical;
  outline: none;
}

.ct-comment-input-modal-textarea:focus {
  border-color: var(--interactive-accent);
}

.ct-comment-input-modal-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
}
```

**Step 2: Commit**

```bash
git add styles.css
git commit -m "feat: add plugin styles for comments and panel"
```

---

### Task 12: Build and Verify

**Step 1: Build the plugin**

Run: `cd /Users/daverigie/Documents/obsidian-comment-threads && npm run build`
Expected: Successful build producing `main.js`

**Step 2: Verify output files exist**

Run: `ls -la /Users/daverigie/Documents/obsidian-comment-threads/main.js`
Expected: File exists with reasonable size

**Step 3: Fix any compilation errors**

If there are errors, fix them and re-run the build.

**Step 4: Commit the final state**

```bash
git add -A
git commit -m "feat: complete initial plugin build"
```

---

### Task 13: Test in Obsidian

**Step 1: Symlink plugin into an Obsidian vault for testing**

Identify or create a test vault. Create the plugin directory and symlink:

```bash
# Adjust VAULT_PATH to your test vault
VAULT_PATH="$HOME/Documents/test-vault"
mkdir -p "$VAULT_PATH/.obsidian/plugins/comment-threads"
cp /Users/daverigie/Documents/obsidian-comment-threads/main.js "$VAULT_PATH/.obsidian/plugins/comment-threads/"
cp /Users/daverigie/Documents/obsidian-comment-threads/manifest.json "$VAULT_PATH/.obsidian/plugins/comment-threads/"
cp /Users/daverigie/Documents/obsidian-comment-threads/styles.css "$VAULT_PATH/.obsidian/plugins/comment-threads/"
```

**Step 2: Enable the plugin in Obsidian**

1. Open the test vault in Obsidian
2. Go to Settings > Community plugins
3. Enable "Comment Threads"

**Step 3: Manual test checklist**

- [ ] Set author name in plugin settings
- [ ] Select text and press Cmd+Shift+M â€” comment modal appears
- [ ] Enter comment body and submit â€” text gets highlighted, panel shows thread
- [ ] Click highlighted text â€” panel highlights corresponding thread
- [ ] Click thread in panel â€” editor scrolls to highlighted text
- [ ] Add a reply in the panel â€” message appears in thread
- [ ] Resolve a thread â€” thread dims, shows resolved status
- [ ] Delete a thread â€” thread removed, markers stripped from text
- [ ] Check that `.comments.json` is created next to the `.md` file
- [ ] Check that `.comments.md` companion file is generated
- [ ] Close and reopen the file â€” comments persist
- [ ] Right-click selected text â€” "Add comment" appears in context menu
- [ ] Open a file from Gutter's demo folder â€” existing Gutter comments load correctly

**Step 4: Commit any fixes**

```bash
git add -A
git commit -m "fix: address issues found during manual testing"
```
